Бекенд максимально тупий, перевірка на наявність слів в словнику, повна перевірка всього тексту при любій зміні.

# Фронтенд

код не ідеальний, треба рефакторити


## Intervals:

- є зміщення інтервалів
- немає багато логіки, яка є у вас (наприклад сабміт слова тільки після закінчення вводу)
- є поправка на інтервал у випадку:
  1) відправили на Бекенд
  2) змінили текст
  3) отримали правку з бекенду <- зміщуєм


## Вузькі місця (алгоритмічно)

1) https://gitlab.com/goloveychuk/editor/blob/master/frontend/src/models/index.ts#L83-122


- add() і remove() можна написати O(log(n)) i O(1) (дерево)
- offset() - зараз O(n) для одного diff (обично він один). В теорії можна зробити Log n (див. нижче Offset Tree)



2) https://gitlab.com/goloveychuk/editor/blob/master/frontend/src/models/index.ts#L184-220
зараз O(n) для любої зміни в text, cursor position, inspections
    
- можна уникнути перерахунку при зміні cursor position
- можна спробувати, знаючи які inspections додались або видались, змінювати лише сусідні ноди.
    


## рендерінг

спочатку був focal + react, переписав на свій рендерер:

https://gitlab.com/goloveychuk/editor/commit/dd03f1938ba2084627a7e452f8bcb819f5ede45e**


В цілому лагів не помічаю. Тестив на Core2duo, 2gb. 

Я додав debouncer на бекенд, щоб не просідало коли приходять підряд багато відповідей які міняють стейт.


## Асинхронний рендерінг
Судячи по тому що у вас є деяке відставання зміщення підкреслення якщо зажати пробіл - рендерите асинхронно.

Хз, може в мене нема логіки, яка сильно нагружає, но поки сенсу в асинх рен. не бачу. Хіба можливо для 100% pure editing experience :)


## Offset tree

https://gitlab.com/goloveychuk/editor/blob/master/frontend/src/lib/tree.ts

disclaimer: думаю, все це несе виключно академічну цінність, і якийсь профіт буде з 10000 нод (на практиці ніколи). Думаю webkit з деревами працює набагато довше ніж з массивами.
Плюс webkit після якоїсь кількості ітерацій оптимізовує цикли в плюсовий код, з дереваами в нього наврядчи вийде.

Якщо коротко: бінарне дерево пошуку, вузли - відносне зміщення індекса від батьківського. Для рута - від початку (тобто індекс).

http://take.ms/xjBP5

Це я почав робити. Шось похоже, тільки тут бється по буквам. 

Спачатку була ідея бити зразу речення на ноди, зберігати значення у вузлах. Але заімплементити важко, особливо коли є зміна діапазону тексту в який входить декілька нод. Того не продовжив.

Профіт:
- видалення лог н
- добавлення лог н
- зміщення лог н

Мінуси:
- якщо треба знати start, end: багато арифметичних операцій
- повільно
- память
- складно імплементити, змінювати, баги

Короче фігова ідея, хз нашо я її описав)